---
title: "Fetal to Adult Kidney Markers"
subtitle: "Identification of Novel Markers Driving Maturity of the Fetal Kidney"
author: "Omid Sajjadi"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document: 
    toc: yes
    toc_depth: 2
    toc_float: true
    number_sections: no
    theme: bootstrap
    df_print: paged
    code_folding: hide
    highlight: pygments
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# **Process**
- Here I am going to analyze three datasets: single nucleus human fetal kidney, single nucleus human adult kidney, and single nucleus human in vitro organoids. 
-My objective is to identify markers that are driving the fetal kidney transition from an fetal stage into a adult stage.
-First Step: I will compare the adult vs fetal PEC DEG markers, this will give me an idea of what are the main differences.
-Second Step: I will then plot a pseudotime using the fetal and adult datasets
-Third Step: I will then plot a pseudotime using the fetal, organoid, and adult datasets
-Fourth Step: 


#### The following packages are on CRAN or Bioconductor and can be installed using the install.packages() function or BiocManager::install() function.

```{r}
if (!require("here")) {install.packages("here"); require("here")}

Datasets <- "Datasets"
Outputs <- "Outputs"

if (!dir.exists(here(Datasets))) {dir.create(here(Datasets))}
if (!dir.exists(here(Outputs))) {dir.create(here(Outputs))}
```



```{r load packages, echo=TRUE, warning=FALSE, error=FALSE, message=FALSE, results='hide'}

if (!require("dplyr")) {install.packages("dplyr"); require("dplyr")}
if (!require("Seurat")) {install.packages("Seurat"); require("Seurat")}
if (!require("patchwork")) {install.packages("patchwork"); require("patchwork")}
if (!require("cowplot")) {install.packages("cowplot"); require("cowplot")}
if (!require("ggpubr")) {install.packages("ggpubr"); require("ggpubr")}
if (!require("plotly")) {install.packages("plotly"); require("plotly")}
if (!require("knitr")) {install.packages("knitr"); require("knitr")}
if (!require("htmlwidgets")) {install.packages("htmlwidgets"); require("htmlwidgets")}
if (!require("tidyverse")) {install.packages("tidyverse"); require("tidyverse")} # for titying up data
if (!require("RColorBrewer")) {install.packages("RColorBrewer"); require("RColorBrewer")} # for color brewer
if (!require("sctransform")) {install.packages("sctransform"); require("sctransform")} # for data normalization
if (!require("openxlsx")) {install.packages("openxlsx"); require("openxlsx")} # to save .xlsx files
if (!require("SoupX")) {install.packages("SoupX"); require("SoupX")}
if (!require("readxl")) {install.packages("readxl"); require("readxl")}
if (!require("hdf5r")) {install.packages("hdf5r"); require("hdf5r")}
if (!require("qs")) {install.packages("qs"); require("qs")}
if (!require("slingshot")) {install.packages("slingshot"); require("slingshot")}
if (!require("glmGamPoi")) {BiocManager::install('glmGamPoi'); require("glmGamPoi")} # for data normalization, sctransform
if (!require("EnhancedVolcano")) {BiocManager::install('EnhancedVolcano'); require("EnhancedVolcano")} # volcano plot

library(ggsankey)
library(DoubletFinder)

set.seed(12345)
here()

```






```{r}

# 1) Load your Seurat objects from .qs
HFK_PC <- qread(here("os_code","AdultToFetalMarkers","Datasets","HFK_PC.qs"))
HAK_PC <- qread(here("os_code","AdultToFetalMarkers","Datasets","2021KPMP_healthy_PC.qs"))


DimPlot(HAK_PC)
DimPlot(HFK_PC)

HFK_PC$MaturityLabel <- "HFK_PC"
HAK_PC$MaturityLabel <- "HAK_PC"

# 2) Sanity: make sure they both use the same assay name (typically "RNA")
DefaultAssay(HFK_PC) <- "RNA"
DefaultAssay(HAK_PC) <- "RNA"

# 3) Make cell names unique and add a batch label
HFK_PC <- RenameCells(HFK_PC, add.cell.id = "HFK_PC")
HAK_PC <- RenameCells(HAK_PC, add.cell.id = "HAK_PC")

HFK_PC$batch <- "HFK_PC"
HAK_PC$batch <- "HAK_PC"

# (Optional but recommended) Keep overlapping features to avoid feature-mismatch noise
common_features <- intersect(rownames(HFK_PC), rownames(HAK_PC))
HFK_PC <- subset(HFK_PC, features = common_features)
HAK_PC <- subset(HAK_PC, features = common_features)

# 4) Merge into ONE object
obj <- merge(HFK_PC, y = HAK_PC)
DefaultAssay(obj) <- "RNA"

# 5) If the merged assay *already* contains split layers like counts.1/data.2, JOIN first
if (length(Layers(obj[["RNA"]])) > 3 || any(grepl("\\.\\d+$", Layers(obj[["RNA"]])))) {
  message("Joining pre-existing per-batch layers in merged object...")
  obj[["RNA"]] <- JoinLayers(obj[["RNA"]])
}

# 6) Now split exactly once by your batch metadata, and only for raw/normalized matrices
obj[["RNA"]] <- split(
  obj[["RNA"]],
  f      = obj$batch,
  layers = c("counts","data")
)

##############SANITY CHECK###############
Layers(obj[["RNA"]])       # Expect something like: "HFK_PC", "HAK_PC"
sort(unique(obj$batch))    # Compare to unique batches
table(obj$batch)           # Per-batch counts from metadata
sapply(Layers(obj[["RNA"]]), function(L) {
  ncol(GetAssayData(obj, assay = "RNA", layer = L))  # columns = cells
})
#########################################################

DefaultAssay(obj) <- "RNA"

# 7) Run a quick unintegrated PCA/UMAP (optional, for comparison)
obj <- NormalizeData(obj)
obj <- FindVariableFeatures(obj)
obj <- ScaleData(obj)
obj <- RunPCA(obj)
obj <- FindNeighbors(obj, dims = 1:30, reduction = "pca")
obj <- FindClusters(obj, resolution = 0.6, cluster.name = "unintegrated_clusters")
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca", reduction.name = "umap.unintegrated")

p_unint <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("batch", "unintegrated_clusters"))
print(p_unint)

# 8) INTEGRATE the layers (CCA), producing a shared low-dim space
obj <- IntegrateLayers(
  object        = obj,
  method        = CCAIntegration,
  orig.reduction= "pca",
  new.reduction = "integrated.cca",
  verbose       = FALSE
)

# 9) Re-join layers (so downstream functions that expect a single matrix behave as usual)
obj[["RNA"]] <- JoinLayers(obj[["RNA"]])
rm(HFK_PC, HAK_PC)

# 10) Neighbors/Clusters/UMAP on the integrated space
obj <- FindNeighbors(obj, reduction = "integrated.cca", dims = 1:30)
obj <- FindClusters(obj, resolution = 4)
obj <- RunUMAP(obj, dims = 1:30, reduction = "integrated.cca")

# 11) Plots
p_unint <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("batch", "unintegrated_clusters"))
print(p_unint)

p_int1 <- DimPlot(obj, reduction = "umap", group.by = "batch")
p_int2 <- DimPlot(obj, reduction = "umap", group.by = "seurat_clusters", label = TRUE)
print(p_int1 + p_int2)

```

```{r}
#QC
head(obj)
tail(obj)


#save the obj -> this is the integrated PC data from HFK and HAK
qsave(obj, "combined_PC_integrated.qs")
```


```{r}


# 1) Load your Seurat objects from .qs
HFK_PC <- qread(here("os_code","AdultToFetalMarkers","Datasets","HFK_PC.qs"))
HAK_PC <- qread(here("os_code","AdultToFetalMarkers","Datasets","2021KPMP_healthy_PC.qs"))


DimPlot(HAK_PC)
DimPlot(HFK_PC)

HFK_PC$MaturityLabel <- "HFK_PC"
HAK_PC$MaturityLabel <- "HAK_PC"

# 2) Sanity: make sure they both use the same assay name (typically "RNA")
DefaultAssay(HFK_PC) <- "RNA"
DefaultAssay(HAK_PC) <- "RNA"

# 3) Make cell names unique and add a batch label
HFK_PC <- RenameCells(HFK_PC, add.cell.id = "HFK_PC")
HAK_PC <- RenameCells(HAK_PC, add.cell.id = "HAK_PC")

HFK_PC$batch <- "HFK_PC"
HAK_PC$batch <- "HAK_PC"

# (Optional but recommended) Keep overlapping features to avoid feature-mismatch noise
common_features <- intersect(rownames(HFK_PC), rownames(HAK_PC))
HFK_PC <- subset(HFK_PC, features = common_features)
HAK_PC <- subset(HAK_PC, features = common_features)

# 4) Merge into ONE object
combined_PC <- merge(HFK_PC, y = HAK_PC)
Idents(combined_PC) <- combined_PC$MaturityLabel
DefaultAssay(combined_PC) <- "RNA"
# Run DEG (HFK vs HAK)
deg_results <- FindMarkers(combined_PC, ident.1 = "HFK_PC", ident.2 = "HAK_PC", min.pct = 0.5, logfc.threshold = 0.75)


# Add gene names as a column
deg_results$gene <- rownames(deg_results)

# Genes up in HFK (positive log2FC)
deg_HFK <- deg_results[deg_results$avg_log2FC > 0, ]
deg_HFK_top100 <- head(deg_HFK[order(-deg_HFK$avg_log2FC), ], 100)

# Genes up in HAK (negative log2FC)
deg_HAK <- deg_results[deg_results$avg_log2FC < 0, ]
deg_HAK_top100 <- head(deg_HAK[order(deg_HAK$avg_log2FC), ], 100)

# Save as CSV
write.csv(deg_HFK_top100, here("os_code","AdultToFetalMarkers","Outputs","HFK_top100_DEG.csv"), row.names = FALSE)
write.csv(deg_HAK_top100, here("os_code","AdultToFetalMarkers","Outputs","HAK_top100_DEG.csv"), row.names = FALSE)

```




```{r}
library(SingleCellExperiment)

# Convert to SingleCellExperiment
DefaultAssay(obj) <- "RNA"
obj@assays <- obj@assays["RNA"]

combined_sce <- as.SingleCellExperiment(obj)

# Use integrated UMAP reduction (run via `RunUMAP(..., reduction = "integrated.cca")`)
# This assumes youâ€™ve already done: RunUMAP(obj, reduction = "integrated.cca", ...)
reducedDims(combined_sce)$UMAP <- Embeddings(obj, "umap")  # "umap" uses integrated.cca by default


# Tabulate how clusters break down across batches
table(obj$seurat_clusters, obj$batch)

```


```{r}
library(slingshot)

# Run Slingshot
combined_sce <- slingshot(combined_sce, 
                          clusterLabels = 'seurat_clusters', 
                          reducedDim = 'UMAP', 
                          start.clus = c("25",'5',"12"))  # replace '0' with actual fetal cluster if known

```



```{r}
library(RColorBrewer)

# Get pseudotime values
pt <- slingshot::slingPseudotime(combined_sce)[, 1]  # pseudotime along lineage 1

# Define color palette
colors <- colorRampPalette(brewer.pal(11, "Spectral"))(100)

# Plot UMAP colored by pseudotime
plot(
  reducedDims(combined_sce)$UMAP,
  col = colors[cut(pt, breaks = 100)],
  pch = 16, asp = 1,
  main = "Slingshot Pseudotime"
)

# Add trajectory curves
lines(SlingshotDataSet(combined_sce), lwd = 2, col = 'black')

```


```{r}
umap_coords <- reducedDims(combined_sce)$UMAP
clusters <- combined_sce$seurat_clusters

# Plot with cluster labels
plot(
  umap_coords,
  col = colors[cut(pt, breaks = 100)],
  pch = 16, asp = 1,
  main = "Slingshot Pseudotime with Clusters"
)
text(
  x = tapply(umap_coords[, 1], clusters, mean),
  y = tapply(umap_coords[, 2], clusters, mean),
  labels = names(table(clusters)),
  cex = 0.8, font = 2
)
lines(SlingshotDataSet(combined_sce), lwd = 2, col = 'black')

```
```{r}
pdf("slingshot_pseudotime_umap.pdf", width = 7, height = 6)
plot(
  reducedDims(combined_sce)$UMAP,
  col = colors[cut(pt, breaks = 100)],
  pch = 16, asp = 1,
  main = "Slingshot Pseudotime"
)
lines(SlingshotDataSet(combined_sce), lwd = 2, col = 'black')
dev.off()

```



# Session Info

```{r session info, echo=TRUE, warning=FALSE, error=FALSE, message=FALSE}

sessionInfo()

```

