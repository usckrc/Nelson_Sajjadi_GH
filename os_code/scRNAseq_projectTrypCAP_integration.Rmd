---
title: "CAP & Tryp Integration"
subtitle: "Comparing sc to nucleus" 
author: "Omid Sajjadi"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document: 
    toc: yes
    toc_depth: 2
    toc_float: true
    number_sections: no
    theme: bootstrap
    df_print: paged
    code_folding: hide
    highlight: pygments
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# **Introduction**

Single-cell RNA sequencing (scRNAseq) has become an essential tool for profiling the transcriptional landscape of the kidney, enabling the discovery of cell-type-specific responses in health and disease. However, whole kidney snRNAseq datasets present unique challenges due to their cellular complexity, technical variability, and the need for standardized data reporting. Here, we present a practical framework for the analysis, annotation, and deposition of whole kidney snRNAseq datasets. Our approach outlines recommended steps for quality control, ambient RNA removal, detection and removal of doublets in two capacities, and assessment of batch effects. We propose standardized naming conventions for kidney cell types and subtypes, harmonizing nomenclature across studies to promote clarity and reproducibility. Finally, we provide practical guidelines for preparing and depositing processed data and metadata in public repositories such as the Gene Expression Omnibus (GEO), ensuring accessibility and compliance with FAIR (Findable, Accessible, Interoperable, Reusable) data principles. We provide a code and video tutorials to guide investigators through the analysis of a whole kidney snRNAseq dataset starting with a gene by cell matrix through depositing the dataset on GEO. Together, these recommendations aim to foster transparency, reproducibility, and collaborative advancement in kidney research.



```{r create folders, echo=TRUE, error=FALSE, message=FALSE, warning=FALSE}

if (!require("here")) {install.packages("here"); require("here")}

Datasets <- "Datasets"
Outputs <- "Outputs"

if (!dir.exists(here(Datasets))) {dir.create(here(Datasets))}
if (!dir.exists(here(Outputs))) {dir.create(here(Outputs))}

#tree "/Users/omidsajjadi/Desktop/Nephronomics" /F
```


```{r install packages, echo=TRUE, warning=FALSE, error=FALSE, message=FALSE}


#install.packages("remotes")
#remotes::install_github('chris-mcginnis-ucsf/DoubletFinder', force = TRUE)

#install.packages("devtools")
#devtools::install_github("davidsjoberg/ggsankey")

```


```{r load packages, echo=TRUE, warning=FALSE, error=FALSE, message=FALSE, results='hide'}

if (!require("dplyr")) {install.packages("dplyr"); require("dplyr")}
if (!require("Seurat")) {install.packages("Seurat"); require("Seurat")}
if (!require("patchwork")) {install.packages("patchwork"); require("patchwork")}
if (!require("cowplot")) {install.packages("cowplot"); require("cowplot")}
if (!require("ggpubr")) {install.packages("ggpubr"); require("ggpubr")}
if (!require("plotly")) {install.packages("plotly"); require("plotly")}
if (!require("knitr")) {install.packages("knitr"); require("knitr")}
if (!require("htmlwidgets")) {install.packages("htmlwidgets"); require("htmlwidgets")}
if (!require("tidyverse")) {install.packages("tidyverse"); require("tidyverse")} # for titying up data
if (!require("RColorBrewer")) {install.packages("RColorBrewer"); require("RColorBrewer")} # for color brewer
if (!require("sctransform")) {install.packages("sctransform"); require("sctransform")} # for data normalization
if (!require("openxlsx")) {install.packages("openxlsx"); require("openxlsx")} # to save .xlsx files
if (!require("SoupX")) {install.packages("SoupX"); require("SoupX")}
if (!require("readxl")) {install.packages("readxl"); require("readxl")}
if (!require("hdf5r")) {install.packages("hdf5r"); require("hdf5r")}

if (!require("glmGamPoi")) {BiocManager::install('glmGamPoi'); require("glmGamPoi")} # for data normalization, sctransform
if (!require("EnhancedVolcano")) {BiocManager::install('EnhancedVolcano'); require("EnhancedVolcano")} # volcano plot

library(ggsankey)
library(DoubletFinder)

set.seed(12345)
here()


```


```{r}
# Core packages
library(Seurat)
library(qs)
library(ggplot2)
library(patchwork)

# 1) Load your Seurat objects from .qs
TRYP <- qread(here("Outputs","AnnotatedTrypSeurat.qs"))
CAP  <- qread(here("Outputs","AnnotatedCAPSeurat.qs"))

# 2) Sanity: make sure they both use the same assay name (typically "RNA")
DefaultAssay(TRYP) <- "RNA"
DefaultAssay(CAP)  <- "RNA"

# 3) Make cell names unique and add a batch label
TRYP <- RenameCells(TRYP, add.cell.id = "TRYP")
CAP  <- RenameCells(CAP,  add.cell.id = "CAP")

TRYP$batch <- "TRYP"
CAP$batch  <- "CAP"

# (Optional but recommended) Keep overlapping features to avoid feature-mismatch noise
common_features <- intersect(rownames(TRYP), rownames(CAP))
TRYP <- subset(TRYP, features = common_features)
CAP  <- subset(CAP,  features = common_features)

# 4) Merge into ONE object
obj <- merge(TRYP, y = CAP)
DefaultAssay(obj) <- "RNA"


# 2) If the merged assay *already* contains split layers like counts.1/data.2, JOIN first
#    (This makes the assay single-layer again so we can split exactly once by 'batch')
if (length(Layers(obj[["RNA"]])) > 3 || any(grepl("\\.\\d+$", Layers(obj[["RNA"]])))) {
  message("Joining pre-existing per-batch layers in merged object...")
  obj[["RNA"]] <- JoinLayers(obj[["RNA"]])
}

# 3) Now split exactly once by your batch metadata, and only for raw/normalized matrices
#    (don't layer scale.data unless you really want to)
obj[["RNA"]] <- split(
  obj[["RNA"]],
  f      = obj$batch,
  layers = c("counts","data")
)



##############SANITY CHECK###############
# Expect something like: "TRYP", "CAP"
Layers(obj[["RNA"]])

# Compare to unique batches:
sort(unique(obj$batch))


# Per-batch counts from metadata
table(obj$batch)

# Per-layer cell counts from matrices (use 'layer=' in Seurat v5)
sapply(Layers(obj[["RNA"]]), function(L) {
  ncol(GetAssayData(obj, assay = "RNA", layer = L))  # columns = cells
})

# Per-batch counts from metadata
table(obj$batch)

# Per-layer cell counts from matrices (use 'layer=' in Seurat v5)
sapply(Layers(obj[["RNA"]]), function(L) {
  ncol(GetAssayData(obj, assay = "RNA", layer = L))  # columns = cells
})
#########################################################


DefaultAssay(obj) <- "RNA"


# 6) Run a quick unintegrated PCA/UMAP (optional, for comparison)
obj <- NormalizeData(obj)
obj <- FindVariableFeatures(obj)
obj <- ScaleData(obj)
obj <- RunPCA(obj)
obj <- FindNeighbors(obj, dims = 1:30, reduction = "pca")
obj <- FindClusters(obj, resolution = 0.6, cluster.name = "unintegrated_clusters")
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca", reduction.name = "umap.unintegrated")

p_unint <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("batch", "unintegrated_clusters"))
print(p_unint)

# 7) INTEGRATE the layers (CCA), producing a shared low-dim space
obj <- IntegrateLayers(
  object        = obj,
  method        = CCAIntegration,
  orig.reduction= "pca",
  new.reduction = "integrated.cca",
  verbose       = FALSE
)

# 8) Re-join layers (so downstream functions that expect a single matrix behave as usual)
obj[["RNA"]] <- JoinLayers(obj[["RNA"]])
rm(TRYP, CAP)
# 9) Neighbors/Clusters/UMAP on the integrated space
obj <- FindNeighbors(obj, reduction = "integrated.cca", dims = 1:30)
obj <- FindClusters(obj, resolution = 4)
obj <- RunUMAP(obj, dims = 1:30, reduction = "integrated.cca")

# 10) Plots
p_unint <- DimPlot(obj, reduction = "umap.unintegrated", group.by = c("batch", "unintegrated_clusters"))
print(p_unint)

p_int1 <- DimPlot(obj, reduction = "umap", group.by = "batch")
p_int2 <- DimPlot(obj, reduction = "umap", group.by = "seurat_clusters", label = TRUE)
p_int1 + p_int2
```

```{r}
plot_batch <- function(obj, reduction, alpha_tryp = 0.2, size = 0.6) {
  emb <- as.data.frame(Embeddings(obj, reduction))
  emb$cell  <- rownames(emb)
  emb$batch <- obj$batch[emb$cell]

  xcol <- colnames(emb)[1]; ycol <- colnames(emb)[2]

  ggplot() +
    geom_point(
      data = subset(emb, batch == "TRYP"),
      aes_string(x = xcol, y = ycol),
      color = "#377EB8", alpha = alpha_tryp, size = size
    ) +
    geom_point(
      data = subset(emb, batch == "CAP"),
      aes_string(x = xcol, y = ycol),
      color = "red", alpha = 0.03, size = size
    ) +
    coord_equal() +
    theme_classic(base_size = 12)
}

# Example: show integrated map with TRYP at 20% opacity
plot_batch(obj, reduction = "umap", alpha_tryp = 0.1) 
plot_batch(obj, reduction = "umap.unintegrated", alpha_tryp = 0.15)
```





```{r first mdd, echo=TRUE, warning=FALSE, error=FALSE, message=FALSE, fig.height=11, fig.width=20}


# cell_type_markers_df <- data.frame(
#   Subclass = c(
#     "PTS", "PTS2", "PTS3", "DTL", "TALA", "TALB", "MD", "DCT1", "DCT2", "CNT",
#     "PC", "ICA", "ICB", "PODO", "PEC", "URO", "EC", "LYMPH", "FIB", "MES", "VSMC", "LYMPHO", "MACRO"
#   ),
#   Positive_Marker_1 = c(
#     "Lrp2", "Lrp2", "Lrp2", "Epha7", "Slc12a1", "Slc12a1", "Nos1", "Slc12a3", "Slc12a3", "Slc8a1",
#     "Aqp2", "Slc4a1", "Slc26a4", "Nphs1", "Ncam1", "Upk1b", "Flt1", "Lyve1", "Pdgfra", "Pdgfrb", "Pdgfrb", "Ptprc", "Ptprc"
#   ),
#   Positive_Marker_2 = c(
#     "Slc5a12", "Slc13a3", "Slc16a9", "Cryab", "Cldn16", "Cldn10", "Slc12a1", "Egf", "Slc8a1", NA,
#     NA, "Kit", NA, NA, NA, NA, "Emcn", "Kdr", "Pdgfrb", "Piezo2", "Acta2", "Skap1", "Cd74"
#   ),
#   stringsAsFactors = FALSE
# )

# Creating a dot plot to cross reference the features with the cell clusters present, seeing the average expression and percent expressed 
markers.to.plot1 <- c("EYA1",    # NPC
                      "SIX2",    # NPC
                      "CITED1",  # NPC
                      
                      "NPHS1",   # PODO
                      "NPHS2",   # PODO
                      "PODXL",   # PODO
                      "CLIC5",   # PODO
                      "MAFBF",   # PODO
                      "PTPRO",   # PODO
                      
                      "CFH",     # PEC
                      "CLDN1",   # PEC
         
                      "SLC22A1", # PT
                      "SLC22A2", # PT
                      "SLC22A3", # PT
                      "SLC22A6", # PT
                      "SLC22A8", # PT
                      "SLC34A1", # PT
                      "LRP2",    # PT
                      "HNF4A",   # PT
                      "SLC5A1",  # PT
                      "SLC5A2",  # PT
                      "ABCC2",   # PT
                      "ABCG2",   # PT
                      "SLC47A1", # PT
                      "SLC23A1", # PT
                      "SLC38A3", # PT
                      "SLC13A2", # PT

                      "CALB1",   # CNT
                      "S100G",   # CNT
                      "TRPV5",   # CNT
                      "KCNE1",   # CNT
                      "SLC2A9",  # CNT
                      "EMX1",    # CNT
                      "VDR",     # CNT
            
                      "TMEM52B", # CNT, DT
                      "SLC12A3", # DT
                      "GATA3",   # DT, PC, UE
                      "RHBG",    # DT
                      "TFAP2A",  # DN, DT
                      "SLC12A1", # DN, LoH
                      "POU3F3",  # DN
                      "TFCP2L1", # DN, LoH
                      
                      "UPK1A",   #DmC
                  
                      "UMOD",    # LoH
                      "AQP1",    # LoH
                      "SPTSSB",  # LoH
                      "MECOM",   # LoH
                      "ESRRG",   # LoH
                      
                     
                      "AQP2",    # PC
                      "SCNN1G",  # PC
                      
                      "FOXI1",     # IC
                      "ATP6V1B1",  # IC
                      "ATP6V0D2",  # IC
                      "ATP6V1C2",  # IC
                      "ATP6V1G3",  # IC
                      "CA2",       # IC
                      "SLC4A1",    # IC
                      "SLC4A9",    # IC
                      "SLC26A4",   # IC
                      "RHCG",      # IC
                 
                      "KRT19",   # UE
                      "FOXQ1",   # UE
                      
                      "RET",     # UPC
                      "WNT11",   # UPC
                      
                      "CD34",   # Endo
                      "CDH5",   # Endo
                      "MCAM",   # Endo
                      "KDR",    # Endo
                      "FLT1",   # Endo
                      "ESM1",   # Endo
                      "EGFL7",  # Vasc
                      "PLVAP",  # Vasc
                      
                      "PDGFRA", # Int
                      "PDGFRB", # Int
                      "DCN",    # Int
                      "POSTN",  # Int
                      "MEIS1",  # Int
                      "MEIS2",  # Int
                      "MEIS3",  # Int
                      
                      "IKZF1",  # Imm
                      "CD36",   # Imm
                     
                      "MAP6",   # NEURO
                      "SOX2",   # NEURO
                      
                      "REN"     #Renin
                      
                      
                      
                      
)

Idents(obj) <- obj$seurat_clusters

p1 <- DotPlot(obj,
features = markers.to.plot2,
group.by = "seurat_clusters",
dot.scale = 8,
dot.min = 0,
scale.max = 100,
scale.min = 0,
col.min = -2.5,
col.max = 2.5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  coord_flip() +
  labs(x = "Gene Features", y = "Clusters")

p1

```


## Annotate by Subclass

Use the list of kidney markers in the table above to determine the identity of each of the clusters. Then in the code below, enter the name of the cluster (as shown in the table above). <br>

For example, **Cluster 0** expresses **Flt1** and **Emcn**, which are **Endothelial Markers**. Therefore add **"EC"** into the line of code here: `seurat_clusters == 0 ~ "EC"` to annotate this cluster as "EC" <br>

Then repeat for the rest of the clusters. <br>

By using the **same cell type nomeclature** in the table, we will be able to **automatically annotate** the clusters at the **class** and **type** level and provide proportion plots. 

If you notice that there are additional clusters that have **characteristics consistent with doublets**, then call them `DOUBLETS` and they will be filtered out at the end of this chunk. However, we do not recluster after this step, as we've found that the removal of this small number of cell doesn't alter the clustering significantly.



```{r group clean data by subclass, warning=FALSE, error=FALSE, message=FALSE}
# Apply names to the clusters by subclass
obj@meta.data <- obj@meta.data %>% mutate(subclass = dplyr::case_when(
seurat_clusters == 0 ~ "PODO",
seurat_clusters == 1 ~ "PODO",
seurat_clusters == 2 ~ "PODO",
seurat_clusters == 3 ~ "PODO",
seurat_clusters == 4 ~ "PODO",
seurat_clusters == 5 ~ "PODO", 
seurat_clusters == 6 ~ "PODO",
seurat_clusters == 7 ~ "PT",
seurat_clusters == 8 ~ "PODO",
seurat_clusters == 9 ~ "PT",
seurat_clusters == 10 ~ "PODO",
seurat_clusters == 11 ~ "PEC",
seurat_clusters == 12 ~ "PEC",
seurat_clusters == 13 ~ "PODO",
seurat_clusters == 14 ~ "PODO",
seurat_clusters == 15 ~ "PODO",
seurat_clusters == 16 ~ "PT",
seurat_clusters == 17 ~ "PODO",
seurat_clusters == 18 ~ "PODO",
seurat_clusters == 19 ~ "PODO",
seurat_clusters == 20 ~ "PT",
seurat_clusters == 21 ~ "LOH",
seurat_clusters == 22 ~ "PODO",
seurat_clusters == 23 ~ "PT",
seurat_clusters == 24 ~ "PODO",
seurat_clusters == 25 ~ "LOH",
seurat_clusters == 26 ~ "LOH",
seurat_clusters == 27 ~ "PODO",
seurat_clusters == 28 ~ "DT",
seurat_clusters == 29 ~ "INT",
seurat_clusters == 30 ~ "LOH",
seurat_clusters == 31 ~ "INT",
seurat_clusters == 32 ~ "DOUBLET",
seurat_clusters == 33 ~ "LOH",
seurat_clusters == 34 ~ "DT",
seurat_clusters == 35 ~ "DOUBLET",
seurat_clusters == 36 ~ "PT",
seurat_clusters == 37 ~ "INT",
seurat_clusters == 38 ~ "INT"

))

# Filter out the doublets

seurat.obj.f_cleaned <- subset(obj, subset = subclass == "DOUBLET", invert = TRUE)

subclass_order <- c("PEC","PT","LOH", "DT", "PODO", "INT" )

seurat.obj.f_cleaned@meta.data$subclass <- factor(seurat.obj.f_cleaned@meta.data$subclass, levels = subclass_order)

# Change the identities to align with new subclass names and make umap
Idents(seurat.obj.f_cleaned) <- seurat.obj.f_cleaned@meta.data$subclass

DimPlot(seurat.obj.f_cleaned, reduction = "umap", label = TRUE, label.size = 4) +  
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste0("Subclass Annotation for Integrated Tryp + CAP Data"))


FeaturePlot(seurat.obj.f_cleaned, reduction = "umap",features = c("MECOM","ESRRG", "GATA3", "SLC12A1") )
FeaturePlot(seurat.obj.f_cleaned, reduction = "umap",features = c("POSTN", "NPHS1"), blend = TRUE)

VlnPlot(seurat.obj.f_cleaned, features = c("NPHS1", "NPHS2"), ncol = 2, group.by = "batch")
VlnPlot(seurat.obj.f_cleaned, features = c("LRP2","HNF4A"), ncol = 2, group.by = "batch")
VlnPlot(seurat.obj.f_cleaned, features = c("CFH", "CLDN1"), ncol = 2, group.by = "batch")
VlnPlot(seurat.obj.f_cleaned, features = c("ESRRG", "MECOM"), ncol = 2, group.by = "batch")
VlnPlot(seurat.obj.f_cleaned, features = c("SLC12A3", "POU3F3"), ncol = 2, group.by = "batch")
VlnPlot(seurat.obj.f_cleaned, features = c("POSTN", "MEIS2"), ncol = 2, group.by = "batch")
```



```{r subtype DEG list , echo=TRUE, warning=FALSE, error=FALSE, message=FALSE}
## Save Excel Spreadsheet 

### This code creates an Excel Spreadsheet of DEG List by Subtype

#The file will be located in the **Outputs** folder. 



# Step 1: Find markers (grouped by subclass)
all_markers <- FindAllMarkers(
  seurat.obj.f_cleaned,
  only.pos = TRUE,
  min.pct = 0.5,
  logfc.threshold = 1,
  group.by = "subclass"  # grouping by subclass instead of cluster ID
)

# Step 2: Sort markers by descending log2FC, put gene column first
all_markers <- all_markers %>%
  arrange(desc(avg_log2FC)) %>%
  select(gene, everything())

# Step 3: Split markers by subclass (stored in 'cluster' column still)
marker_list <- split(all_markers, all_markers$cluster)

# Step 4: Reorder the list according to your subclass_order
# First ensure you're only including subclasses that are actually present
valid_subclasses <- subclass_order[subclass_order %in% names(marker_list)]

# Reorder marker_list based on that
marker_list <- marker_list[valid_subclasses]

# Step 5: Write to Excel
wb <- createWorkbook()

for (subclass in names(marker_list)) {
  addWorksheet(wb, sheetName = subclass)
  writeData(wb, sheet = subclass, marker_list[[subclass]])
}

# Step 6: Save file
date <- format(Sys.Date(), "%Y%m%d")
saveWorkbook(
  wb,
  here("Outputs", paste0(date, "_", sample_name, "_FindAllMarkers_By_Subclass.xlsx")),
  overwrite = TRUE
)
```


## Type Annotation

Give an image with 3 separate examples of well-annotated kidney datasets.

```{r make clean subclass mdd diagonal, warning=FALSE, error=FALSE, message=FALSE}
# Change the order of the identities on the x-axis to create a diagonal on the dotplot, going from top to bottom of the "naming kidney cells" table

markers.to.plot2 <- c(
                      
                      "NPHS1",   # PODO
                      "NPHS2",   # PODO
                      "PODXL",   # PODO
                      "CLIC5",   # PODO
                      "MAFBF",   # PODO
                      "PTPRO",   # PODO
                      
                      "CFH",     # PEC
                      "CLDN1",   # PEC
         
                      "SLC22A1", # PT
                      "SLC22A2", # PT
                      "SLC22A3", # PT
                      "SLC22A6", # PT
                      "SLC22A8", # PT
                      "SLC34A1", # PT
                      "LRP2",    # PT
                      "HNF4A",   # PT
                     
                      "MECOM",   # LoH
                      "ESRRG",   # LoH
                      "EMX1",    # CNT
                      "VDR",     # CNT
            
                      "TMEM52B", # CNT, DT
                      "SLC12A3", # DT
                      "GATA3",   # DT, PC, UE
                      "RHBG",    # DT
                      "TFAP2A",  # DN, DT
                      "SLC12A1", # DN, LoH
                      "POU3F3",  # DN
                      "TFCP2L1", # DN, LoH
                      
                      "UPK1A",   #DmC
                  
                     
                      
                     
                      "AQP2",    # PC
                      "SCNN1G",  # PC
                      
                
                      
                      "PDGFRA", # Int
                      "PDGFRB", # Int
                      "DCN",    # Int
                      "POSTN",  # Int
                      "MEIS1",  # Int
                      "MEIS2",  # Int
                      "MEIS3"  # Int
                      
                
                      
                      
                      
                      
)
subclass_order <- c("PODO","PEC","PT", "LOH", "DT", "INT" )
seurat.obj.f_cleaned$subclass <- factor(seurat.obj.f_cleaned$subclass, levels = subclass_order)
DotPlot(seurat.obj.f_cleaned,
features = markers.to.plot2,
group.by = "subclass",
dot.scale = 8,
dot.min = 0,
scale.max = 100,
scale.min = 0,
col.min = -2.5,
col.max = 2.5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  coord_flip() +
  labs(x = "Gene Features", y = "Clusters") +  
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste0("Subclass Annotation for Integrated Tryp + CAP Data"))
```




```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)

target_ct <- c("PEC","PT","LOH","DT","PODO","INT")

meta <- seurat.obj.f_cleaned@meta.data
if (!"subclass" %in% colnames(meta)) {
  meta$subclass <- as.character(Idents(seurat.obj.f_cleaned))
}

# Count cells and compute proportions (overall)
comp <- meta %>%
  mutate(subclass = as.character(subclass)) %>%
  filter(subclass %in% target_ct) %>%
  count(subclass, name = "n") %>%
  complete(subclass = target_ct, fill = list(n = 0)) %>%
  mutate(
    prop     = n / sum(n),
    subclass = factor(subclass, levels = target_ct)
  )

# Single stacked bar (overall)
ggplot(comp, aes(x = "All cells", y = prop, fill = subclass)) +
  geom_col(width = 0.5) +
  geom_text(
    aes(label = paste0(subclass, ": ", n, " (", percent(prop, accuracy = 0.1), ")")),
    position = position_stack(vjust = 0.5), color = "white", size = 4
  ) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  labs(x = NULL, y = "Proportion of cells",
       title = "Proportion of Cells (by subclass)") +
  theme_classic() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```




```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)

target_ct <- c("PEC","PT","LOH","DT","PODO","INT")

meta <- seurat.obj.f_cleaned@meta.data
stopifnot(all(c("batch","subclass") %in% colnames(meta)))

# keep all batch levels even if a batch has 0 target cells
batches <- sort(unique(as.character(meta$batch)))

comp_by_batch <- meta %>%
  transmute(
    batch    = as.character(batch),
    subclass = toupper(trimws(as.character(subclass)))   # clean spaces/case
  ) %>%
  replace_na(list(subclass = "UNKNOWN")) %>%
  filter(subclass %in% target_ct) %>%                      # count ONLY target classes
  count(batch, subclass, name = "n") %>%
  complete(batch = batches, subclass = target_ct, fill = list(n = 0)) %>%  # keep empty batches too
  group_by(batch) %>%
  mutate(
    total_batch = sum(n),                                  # sum within EACH batch
    prop        = ifelse(total_batch > 0, n / total_batch, 0)
  ) %>%
  ungroup() %>%
  mutate(subclass = factor(subclass, levels = target_ct))

ggplot(comp_by_batch, aes(x = "All cells", y = prop, fill = subclass)) +
  geom_col(width = 0.5) +
  geom_text(
    aes(label = paste0(subclass, ": ", n, " (", percent(prop, accuracy = 0.1), ")")),
    position = position_stack(vjust = 0.5),
    color = "white",
    size = 3
  ) +
  facet_wrap(~ batch, nrow = 1) +
  scale_y_continuous(labels = NULL, breaks = NULL, expand = c(0, 0)) +
  labs(title = "Proportion of Cells per Batch") +
  theme_classic() +
  theme(
    axis.title  = element_blank(),
    axis.text   = element_blank(),
    axis.ticks  = element_blank(),
    axis.line   = element_blank()
  )
```






# **QC Reports**

## Progression of cells Filtering Through the Analysis of **`r sample_name`**

```{r make sankey plot, echo=TRUE, warning=FALSE, error=FALSE, message=FALSE}

Start_name <- paste0(as.character(Start), " cells")
Filter_1_name <- paste0(as.character(Filter_1), " cells")
Filter_2_name <- paste0(as.character(Filter_2), " cells")
Filter_3_name <- paste0(as.character(Filter_3), " cells")


df_paths2 <- data.frame(
  group = c("Pass_All", "Filtered_at_3", "Filtered_at_2", "Filtered_at_1"),
  CellRanger = c(Start_name,     Start_name,       Start_name,        Start_name),
  nFeature = c(Filter_1_name,  Filter_1_name,    Filter_1_name,     paste0(as.character(Start-Filter_1), " cells removed")),
  doubletFinder = c(Filter_2_name,  Filter_2_name,   paste0(as.character(Filter_1-Filter_2), " cells removed"),    NA),
  ManualDoublets = c(Filter_3_name, paste0(as.character(Filter_2-Filter_3), " cells removed"),      NA,       NA),
  value = c(Start,        Filter_2-Filter_3,          Filter_1-Filter_2,           Start-Filter_1)
)


df_paths2b <- data.frame(
  group = c("Pass_All", "Filtered_at_3", "Filtered_at_2", "Filtered_at_1"),
  CellRanger = c(Start_name, Start_name, Start_name, Start_name),
  nFeature = c(Filter_1_name, Filter_1_name, Filter_1_name, paste0(as.character(Start - Filter_1), " cells removed")),
  doubletFinder = c(Filter_2_name, Filter_2_name, paste0(as.character(Filter_1 - Filter_2), " cells removed"), NA),
  ManualDoublets = c(Filter_3_name, paste0(as.character(Filter_2 - Filter_3), " cells removed"), NA, NA),
  Final = c(Filter_3_name , NA, NA, NA),
  value = c(Start, Filter_2 - Filter_3, Filter_1 - Filter_2, Start - Filter_1)
)

# Convert to long format suitable for ggsankey
df_sankey <- df_paths2b   %>%
  make_long(CellRanger, nFeature, doubletFinder, ManualDoublets, Final, value = "value")

# make removed nodes gray
orig_levels <- levels(factor(df_sankey$node))
orig_palette <- scales::hue_pal()(length(orig_levels))
names(orig_palette) <- orig_levels

# Override only "removed" nodes to gray
custom_palette <- orig_palette
custom_palette[grepl("removed", names(custom_palette))] <- "gray"

# change font size of removed nodes
df_sankey <- df_sankey %>%
  filter(!is.na(node))%>%
  mutate(is_removed = grepl("removed", node),
         label_size = ifelse(is_removed, 3, 4))

# specify order
df_sankey$node <- factor(df_sankey$node, levels = rev(unique(df_sankey$node)))
df_sankey$next_node <- factor(df_sankey$next_node, levels = rev(unique(df_sankey$node)))

# Do the same for next_node
df_sankey$next_node <- factor(df_sankey$next_node, levels = levels(df_sankey$node))


# Plot
ggplot(df_sankey, aes(x = x,
                      next_x = next_x,
                      node = node,
                      next_node = next_node,
                      value = value,
                      fill = factor(node))) +
  geom_sankey(flow.alpha = 0.7, node.color = "black") +
  geom_sankey_label(aes(label = node, size = label_size), color = "white", show.legend = FALSE) +
  scale_fill_manual(values = custom_palette) +   
  scale_color_identity() +
  scale_size_identity() +
  theme_classic() +
labs(
  title = paste0("Filtering Progression Sankey Plot for ", sample_name),
  x = ""
) +
  theme(
    # Remove Y-axis
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.line.y = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),

    # Remove X-axis lines
    axis.line.x = element_blank(),
    axis.ticks.x = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),

    # Enlarge text
    axis.text.x = element_text(size = 14),
    axis.title.x = element_text(size = 16),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),

    # Hide legend
    legend.position = "none"
  )

```



#ST-INT-PEC Subcluster


```{r}
ST.INT.PEC.Subcluster <- subset(seurat.obj.f_cleaned, idents = c("ST-INT-PEC"))
levels(Idents(ST.INT.PEC.Subcluster))
```




```{r}

seurat.obj._ST.INT.PEC <- SCTransform(ST.INT.PEC.Subcluster) %>%
    RunPCA() %>%
    FindNeighbors(dims = 1:30) %>%
    FindClusters(resolution = 0.25, verbose = FALSE) %>%
    RunUMAP(dims = 1:30)

DimPlot(seurat.obj._ST.INT.PEC, reduction = "umap", label = TRUE) +  
  theme(plot.title = element_text(hjust = 0.5)) +
  ggtitle(paste0("Non-annotated ST-INT-PEC subclusters for ", sample_name))

DefaultAssay(seurat.obj._ST.INT.PEC) <- "RNA"

```


```{r}
markers.to.plot2 <- c("CFH",          # PEC
                      "CLDN1",        # PEC
                      "COL1A2",       # ST
                      "TNC",          # ST
                      "COL6A3",       # ST
                      "LGALS1",       # ST
                      "PDGFRA",       # INT
                      "POSTN",        # INT
                      "IGFBP5",       # INT
                      "ALX1",         # INT
                      "MEIS1",        # INT
                      "AGTR1A",       # INT
                      "SFRP1",        # INT
                      "TBX18",        # INT
                      "IGF1",         # INT
                      "DCN",          # ICb
                      "DES",          # ICb
                      "SERPINE2",     # ICb
                      "COL3A1",       # ICb
                      "COL1A1",       #ICa, ICb
                      "LEF1",         #ICa, ICb
                      "FGF7",         #ICa
                      "TPM2",         #ICa, MES
                      "PDGFRB",       # MES
                      "MCAM",         # MES
                      "CSPG4",        # MES
                      "CD248",        # MES
                      "ACTA2"         # MES
                      
                      
)
```




```{r, fig.width=14, fig.height=10}
DotPlot(seurat.obj._ST.INT.PEC,
features = markers.to.plot2,
dot.scale = 8,
dot.min = 0,
scale.max = 100,
scale.min = 0,
col.min = -2.5,
col.max = 2.5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  coord_flip() +
  labs(x = "Gene Features", y = "Clusters")

FeaturePlot(seurat.obj._ST.INT.PEC, features = c("TOP2A", "CENPF", "MKI67","HMGB2", "TPX2", "CDK1", "ASPM", "NUF2", "NDC80", "H2AFZ", "SMC4", "UBE2C")) 

FeaturePlot(seurat.obj._ST.INT.PEC, features = c(
  "POSTN", "LGALS1", "COL3A1", "IGFBP5", "SULT1E1", "COL14A1", "IGFBP3",
  "LRRC17", "OGN", "ALDH1A2", "PTN", "C7", "COL1A1", "AKAP12", "PLAT",
  "COL1A2", "CDH11", "TGFB1", "PCOLCE", "CXCL12"
))

FeaturePlot(seurat.obj._ST.INT.PEC, features = c(
  "SHISA3", "CXCL12", "CDH9", "FGF7", "ELMOD1", "GLIPR1", "DLK1", "RSPO3",
  "IGFBP3", "HRC", "LRRC17", "NR2F1", "RCAN2", "IGF2", "MFAP4", "COL1A2",
  "ADAMTS5", "MEIS2", "SERPINE2", "PTN"
))




FeaturePlot(seurat.obj._ST.INT.PEC, features = c(
  "SOX2", "ENO1", "DDIT4", "FABP7", "TTYH1", "CKB", "GAPDH", "BNIP3", "RPS19",
  "TUBB2B", "PGK1", "FAM162A", "RPL3", "VIM", "MAP2", "ALDOA", "RPLP0",
  "HNRNPA1", "RPS6", "TUBA1A"
))

FeaturePlot(seurat.obj._ST.INT.PEC, features = c(
  "CRABP1", "STMN2", "TAGLN3", "MAP2", "GAP43", "MIAT", "TUBB2B", "KIF5C",
  "RTN1", "SYT4", "STMN4", "ELAVL4", "PPP1R17", "DCX", "NSG1", "OLFM1",
  "SRRM4", "INA", "GNG3", "ELAVL2"
))

FeaturePlot(seurat.obj._ST.INT.PEC, features = c(
  "DKK1", "SCG2", "MSX1", "PENK", "CNTNAP2", "LIX1", "RMST", "NELL2",
  "SPARCL1", "COL9A1", "FABP7", "EFNB3", "DMD", "AP1S2", "FAT3", "COLEC12",
  "CDH6", "LSAMP", "LYPD1", "TPBG"
))

FeaturePlot(seurat.obj._ST.INT.PEC, features = c(
  "ACTC1", "MYLPF", "TNNC2", "MYL1", "MYH3", "KLHL41", "ACTA1", "NEB", "TNNT2",
  "TTN", "TNNI1", "ARPP21", "MEF2C", "TNNT1", "ENO3", "TNNT3", "NEXN", "MYH8",
  "PDLIM3", "MYBPH"
))



# Mesenchyme 1
FeaturePlot(seurat.obj._ST.INT.PEC, features = c(
  "CRABP2", "PRRX1", "DSE", "IGF2", "HMGA2", "SEMA3A", "VIM", "TPM2", "PEG10",
  "HNRNPD", "TMSB15A", "PLK2", "HMGB1", "NR2F1", "TUBB", "NASP", "EDNRA",
  "43354", "ZFHX4", "SMC4"
))

# Mesenchyme 2
FeaturePlot(seurat.obj._ST.INT.PEC, features = c(
  "COL3A1", "LGALS1", "LRRC17", "IGFBP5", "IGF1", "DCN", "POSTN", "COL1A2",
  "NRK", "COL6A3", "CDH11", "ALX1", "ALDH1A2", "COL1A1", "ISLR", "THY1",
  "EDNRA", "OLFML3", "CXCL12", "WNT5A"
))

# Mesenchyme 3
FeaturePlot(seurat.obj._ST.INT.PEC, features = c(
  "IGFBP3", "CXCL12", "SFRP1", "SHISA3", "ELMOD1", "GLIPR1", "FILIP1", "DCN",
  "DLK1", "MGP", "COL1A1", "ADAMTS5", "EMCN", "PRSS35", "FBLN5", "MFAP4",
  "TAGLN", "POSTN", "COL3A1", "SLIT3"
))


```


```{r}
Data.markers <- FindAllMarkers(seurat.obj._ST.INT.PEC, only.pos = TRUE, min.pct = 0.5, logfc.threshold = 1) # I can speed up this by increasing threshold and pct
Data.markers %>% group_by(cluster) %>% top_n(n = 5, wt = avg_log2FC)
top5 <- Data.markers %>% group_by(cluster) %>% top_n(5, avg_log2FC)
p44 <- DoHeatmap(seurat.obj._ST.INT.PEC, features = top5$gene) 
p44
```



## Subclass Cell Types That Were Not Annotated in **`r sample_name`**

```{r missing subclass, warning=FALSE, error=FALSE, message=FALSE, results='hide'}

# list1 <- unique(seurat.obj.f_cleaned$subclass)
#   
# list2 <- unique(markers_long$Subclass)
# 
# missing_subclass <- setdiff(list2, list1)
# 
# missing_subclass

```





# **Save** Seurat Object 

## Add Sample Meta.Data to Object


```{r add meta.data, echo=TRUE, warning=FALSE, error=FALSE, message=FALSE, fig.align = 'center'}

# meta <- read.xlsx(here("datasets", "metadata.xlsx"), sheet = 1)
# 
# meta$sample_name <- as.character(meta$sample_name)
# 
# seurat.obj.f_cleaned@meta.data$sample <- sample_name
# 
# df <- FetchData(seurat.obj.f_cleaned, "sample") %>% rownames_to_column(var = "CellID")
# 
# df <- left_join(df, meta, by = c("sample" = "sample_name")) %>% column_to_rownames(var = "CellID")
# 
# seurat.obj.f_cleaned<- AddMetaData(seurat.obj.f_cleaned, df)
# 
# seurat.obj.f_cleaned

```

### **Check** to see if **Meta.Data has been added** to Seurat Object

**Scroll to the right** on the table to check for new meta.data columns.

```{r check meta.data, echo=TRUE, warning=FALSE, error=FALSE, message=FALSE, fig.align = 'center'}

# head(seurat.obj.f_cleaned@meta.data)

```

## This saves the Seurat Object as an .RDS file

This **file is processed** and can be **merged with replicates** in downstream analysis. <br>

It will be saved in the **Outputs** folder.

```{r save clean object, warning=FALSE, error=FALSE, message=FALSE}
# 
# # Add a date to file name
# date <- format(Sys.Date(), "%Y%m%d")
# 
# #saveRDS(seurat.obj.f_cleaned, here("Outputs", paste0(date, sample, ".rds")))

```

# **Acknowledgements**

## Group Leaders

This guide is written based on the experience of multiple trainee's and investigators

These include: <br>

Michael Hutchens <br>
Susan Gurley <br>

## Trainees

Trainee's that contributed to the thinking that went into this guide include:<br>

Roman Thomas <br>
Kevin Burfeind <br>
Xiao-Tong Su<br>
Annie Lackey <br>
Jeremiah Reyes <br>
Sienna Blanche <br>
Jeff Karnsomprot <br>

## Funding Agencies

We are **incredibly grateful** to our **funding agencies** for supporting this work including:

# Session Info

```{r session info, echo=TRUE, warning=FALSE, error=FALSE, message=FALSE}

sessionInfo()

```

